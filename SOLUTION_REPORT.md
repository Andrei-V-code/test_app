# Доработка приложения
1. Добавил ссылку на `build` для компиляции проекта в **package.json**, т.к. изначально это приводило к ошибке, по причине того, что не не был указан конфиг для компиляции.
2. Добавил библиотеки **@emotion/react, @emotion/styled, @mui/material**, чтобы кнопка и поле ввода смотрелись лучше.
3. Добавил спинер, который отображается во время загрузки данных. ![Loading.tsx](/client/src/pages/components/Loading.tsx)
4. Добавил страницу, которая отображается, в случае если элемент не найден. ![NotFound.tsx](/client/src/pages/NotFound.tsx)
5. Добавил типизацию. ![types.ts](/client/src/types.ts)
6. Добавил роутинг в ![App.tsx](/client/src/App.tsx) на страницу **NotFound**.
7. ![Button.tsx](/client/src/pages/components/Button.tsx) - изменил стандартную кнопку, на кнопку из **materil-ui**.
8. ![Header.tsx](/client/src/pages/components/Header.tsx) - вынес `Header` в отдельный компонент и связанную с ним логику. Добавил логику к `SubTitle` для отображения выбранных элементов, так же вынес его в отдельный компонент. ![Subtitle.tsx](/client/src/pages/components/SubTitle.tsx)
9. ![ListItem.tsx](/client/src/pages/components/ListItem.tsx) - создал новый файл и вынес туда рендер одного элемента. Вынес кнопку выбора элемента из перехода на другую страницу, т.к. при нажатии на неё был переход на страницу.
10. ![ListPage.tsx](/client/src/pages/ListPage.tsx) - `activeItemId` изменил на массив, т.к. необходимо запоминать множество активных элементов. Перенёс состояние сортировки, в константу **content** добавил мемоизацию для фильтра и поиска.
11. ![SinglePage.tsx](/client/src/pages/SinglePage.tsx) - добавил навигацию на страницу **NotFound** в случае ошибки.
12. ![useSort](/client/src/pages/useSort.ts) - оставил только саму сортировку в зависимости от типа.

# Выводы
1. Большое количество **useEffect** приводило к многочисленным рендерам приложения.
2. Есть смысл вынести куски кода в отдельные компоненты, это относится к **SubTitle** и **Header**
3. Проблема с постоянным запросом данных и большого количества элементов.
3. В случае, если не удалось получить элемент используя API, необходим обработчик, который проинформирует пользователя что что-то пошло не так.

# Предложения
Допустим у нас большое приложение с большим количеством различных запросов. Можно структурировать их используя `useQuery`, для этого необходимо создать различные сущности и затем обращаться к ним. Добавить кэширование данных, а также реализовать подписку на сущности и отслеживать их изменения, если какая либо из сущностей обновляется, то запросим данные с сервера.